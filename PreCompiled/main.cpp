#include <iostream>
#include <filesystem>
#include <fstream>
#include <sstream>
#include <string>
#include <rapidjson/document.h>
#include <rapidjson/writer.h>
#include <rapidjson/stringbuffer.h>

namespace fs = std::filesystem;
void processJsonFiles(const std::string& inputFolder, const std::string& outputFilePath) {
	std::ofstream outputFile(outputFilePath);
	if (!outputFile.is_open()) {
		std::cerr << "No se pudo crear el archivo de salida: " << outputFilePath << std::endl;
		return;
	}

	// Escribir encabezado del archivo
	outputFile << "#ifndef JSON_DATA_HPP\n";
	outputFile << "#define JSON_DATA_HPP\n\n";
	outputFile << "#include <array>\n";
	outputFile << "#include <tuple>\n";
	outputFile << "#include <string_view>\n\n";

	// Contador de archivos para definir el tamaño del array
	size_t fileCount = 0;
	for (const auto& entry : fs::directory_iterator(inputFolder)) {
		if (entry.is_regular_file() && entry.path().extension() == ".json") {
			++fileCount;
		}
	}

	// Definir el array de tamaño fijo
	outputFile << "constexpr std::array<std::tuple<std::string_view, std::string_view>, " << fileCount << "> json_data = {\n";

	bool firstEntry = true;
	for (const auto& entry : fs::directory_iterator(inputFolder)) {
		if (entry.is_regular_file() && entry.path().extension() == ".json") {
			std::ifstream inputFile(entry.path().string());
			if (!inputFile.is_open()) {
				std::cerr << "No se pudo abrir el archivo: " << entry.path().string() << std::endl;
				continue;
			}

			std::ostringstream oss;
			oss << inputFile.rdbuf();
			std::string jsonContent = oss.str();

			// Compactar JSON
			rapidjson::Document document;
			if (document.Parse(jsonContent.c_str()).HasParseError()) {
				std::cerr << "Error al parsear el JSON en el archivo: " << entry.path().string() << std::endl;
				continue;
			}

			rapidjson::StringBuffer buffer;
			rapidjson::Writer<rapidjson::StringBuffer> writer(buffer);
			document.Accept(writer);

			const std::string compactedJson = buffer.GetString();

			// Dividir el JSON en fragmentos de tamaño fijo si es necesario
			constexpr size_t MAX_FRAGMENT_SIZE = 1024;
			std::vector<std::string> fragments;
			for (size_t i = 0; i < compactedJson.size(); i += MAX_FRAGMENT_SIZE) {
				fragments.emplace_back(compactedJson.substr(i, MAX_FRAGMENT_SIZE));
			}

			// Escribir cada entrada en el archivo .hpp
			if (!firstEntry) {
				outputFile << ",\n";
			}
			firstEntry = false;

			outputFile << "    std::make_tuple(\"" << entry.path().filename().string() << "\", ";
			outputFile << "\n";

			for (size_t i = 0; i < fragments.size(); ++i) {
				outputFile << "        R\"(" << fragments[i] << ")\"";
				if (i < fragments.size() - 1) {
					outputFile << "\n";
				}
			}

			outputFile << ")";
		}
	}

	outputFile << "\n};\n";
	outputFile << "#endif // JSON_DATA_HPP\n";

	std::cout << "Archivo generado: " << outputFilePath << std::endl;
}

int main()
{
	// Carpeta de entrada con los archivos JSON
	const std::string inputFolder = "../Tarea_XXXX"; // Cambiar a tu carpeta de entrada
	const std::string outputFilePath = "./AutoGenerated_JSONData.hpp"; // Archivo de salida

	// Procesar los archivos JSON y generar el archivo .hpp
	processJsonFiles(inputFolder, outputFilePath);

	return 0;
}
