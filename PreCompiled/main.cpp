#include <iostream>
#include <filesystem>
#include <fstream>
#include <sstream>
#include <string>
#include <vector>
#include <rapidjson/document.h>
#include <rapidjson/writer.h>
#include <rapidjson/stringbuffer.h>

void Generate_JSON_Data(const std::string& inputFolder, const std::string& outputFilePath)
{
	namespace fs = std::filesystem;
	std::ofstream outputFile(outputFilePath);
	if (!outputFile.is_open()) {
		std::cerr << "No se pudo crear el archivo de salida: " << outputFilePath << std::endl;
		return;
	}

	// Escribir encabezado del archivo
	outputFile << "////////////////////////////////////////\n";
	outputFile << "// Autogenerated Code, do not Modify! //\n";
	outputFile << "////////////////////////////////////////\n";

	outputFile << "#pragma once\n";
	outputFile << "#include <array>\n";
	outputFile << "#include <tuple>\n";
	outputFile << "#include <string_view>\n\n";

	// Contador de archivos para definir el tamaño del array
	size_t fileCount = 0;
	for (const auto& entry : fs::directory_iterator(inputFolder)) {
		if (entry.is_regular_file() && entry.path().extension() == ".json") {
			++fileCount;
		}
	}

	// Definir el array de tamaño fijo
	outputFile << "constexpr std::array<std::tuple<std::string_view, std::string_view>, " << fileCount << "> json_data = {\n";

	bool firstEntry = true;
	for (const auto& entry : fs::directory_iterator(inputFolder)) {
		if (entry.is_regular_file() && entry.path().extension() == ".json") {
			std::ifstream inputFile(entry.path().string());
			if (!inputFile.is_open()) {
				std::cerr << "No se pudo abrir el archivo: " << entry.path().string() << std::endl;
				continue;
			}

			std::ostringstream oss;
			oss << inputFile.rdbuf();
			std::string jsonContent = oss.str();

			// Compactar JSON
			rapidjson::Document document;
			if (document.Parse(jsonContent.c_str()).HasParseError()) {
				std::cerr << "Error al parsear el JSON en el archivo: " << entry.path().string() << std::endl;
				continue;
			}

			rapidjson::StringBuffer buffer;
			rapidjson::Writer<rapidjson::StringBuffer> writer(buffer);
			document.Accept(writer);

			const std::string compactedJson = buffer.GetString();

			// Dividir el JSON en fragmentos de tamaño fijo si es necesario
			constexpr size_t MAX_FRAGMENT_SIZE = 1024;
			std::vector<std::string> fragments;
			for (size_t i = 0; i < compactedJson.size(); i += MAX_FRAGMENT_SIZE) {
				fragments.emplace_back(compactedJson.substr(i, MAX_FRAGMENT_SIZE));
			}

			// Escribir cada entrada en el archivo .hpp
			if (!firstEntry) {
				outputFile << ",\n";
			}
			firstEntry = false;

			outputFile << "    std::make_tuple(\"" << entry.path().filename().string() << "\", ";
			outputFile << "\n";

			for (size_t i = 0; i < fragments.size(); ++i) {
				outputFile << "        R\"(" << fragments[i] << ")\"";
				if (i < fragments.size() - 1) {
					outputFile << "\n";
				}
			}

			outputFile << ")";
		}
	}

	outputFile << "\n};\n";

	std::cout << "Archivo generado: " << outputFilePath << std::endl;
}

void Generate_PostProcces_Data(const std::string& jsonFile, const std::string& outputHppFile) {

	// Leer archivo JSON
	std::ifstream ifs(jsonFile);
	if (!ifs.is_open()) {
		std::cerr << "Error: No se pudo abrir el archivo " << jsonFile << "\n";
		return;
	}

	std::ostringstream oss;
	oss << ifs.rdbuf();
	std::string jsonContent = oss.str();
	ifs.close();

	// Parsear el JSON desde el string
	rapidjson::Document doc;
	if (doc.Parse(jsonContent.c_str()).HasParseError()) {
		std::cerr << "Error: No se pudo parsear el contenido del archivo JSON.\n";
		return;
	}

	if (!doc.IsObject()) {
		std::cerr << "Error: El archivo JSON no tiene el formato correcto.\n";
		return;
	}

	// Validar que existe el objeto "PostProcess"
	if (!doc.HasMember("PostProcess") || !doc["PostProcess"].IsObject()) {
		std::cerr << "Error: El JSON no contiene un objeto 'PostProcess' válido.\n";
		return;
	}

	const auto& postProcess = doc["PostProcess"];

	// Abrir archivo de salida para generar el .hpp
	std::ofstream out(outputHppFile);
	if (!out.is_open()) {
		std::cerr << "Error: No se pudo crear el archivo " << outputHppFile << "\n";
		return;
	}

	// Lambda para generar el encabezado del archivo
	auto write_header = [&out]() {
		out << "////////////////////////////////////////\n";
		out << "// Autogenerated Code, do not Modify! //\n";
		out << "////////////////////////////////////////\n";
		out << "#pragma once\n\n";
		out << "#include <vector>\n";
		out << "#include <string>\n\n";
		out << "class PostProcess;\n";
		out << "using FunctionPointer = bool (PostProcess::*)();\n\n";
		};

	// Lambda para escribir los datos principales en un vector
	auto write_data_vector = [&out](const rapidjson::Value& postProcess) {
		out << "static const std::vector<std::pair<std::string, std::vector<FunctionPointer>>> postProcessData = {\n";

		for (auto it = postProcess.MemberBegin(); it != postProcess.MemberEnd(); ++it) {
			std::string fileName = it->name.GetString();
			out << "    {\"" << fileName << "\", {\n";

			const auto& funcArray = it->value.GetArray();
			for (const auto& func : funcArray) {
				std::string funcName = func.GetString();
				out << "        " << "&PostProcess::" << funcName << ",\n";
			}

			out << "    }},\n";
		}

		out << "};\n";
		};

	// Llamar a las lambdas para generar el archivo
	write_header();
	write_data_vector(postProcess);

	out.close();
	std::cout << "Archivo " << outputHppFile << " generado correctamente.\n";
}



int main()
{
	Generate_JSON_Data("../Tarea_XXXX", "./AutoGenerated_JSONData.hpp");
	Generate_PostProcces_Data("../Tarea_XXXX/Config.json", "./Autogenerated_PostProcess.hpp");


	return 0;
}
