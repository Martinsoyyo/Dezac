//#pragma once
//#include "Libraries.hpp"
//
//#include "XML.hpp"
//#include "Json.hpp"
//#include "Log.hpp"
//
//class FileManager {
//public:
//	FileManager();
//
//	FileManager(const Document&);
//
//	static std::optional<std::vector<char>> Load(std::string_view filename);
//	static bool Store(std::string_view filename, std::string_view content);
//	static bool SendToMicroSD(std::string_view filename, std::string_view content);
//};
//
///////////////////////////////////////////////////
//inline FileManager FILEMANAGER; /// OBJETO GLOBAL
///////////////////////////////////////////////////
//

#ifndef APPLICATION_FILEMANAGER_FILEMANAGER_HPP_
#define APPLICATION_FILEMANAGER_FILEMANAGER_HPP_

#include "Libraries.hpp"
#include "AutoGenerated_JSONData.hpp"
#include "Log.hpp"

// Definiciones para los parámetros de la Flash simulada
#define LFS_BLOCK_SIZE  256  // Tamaño del bloque simulado
#define LFS_BLOCK_COUNT 256  // Número de bloques disponibles

class FileManager {
public:
	FileManager() {
		std::memset(flash_buffer, 0xFF, FLASH_SIZE); // Inicializa con 0xFF (Flash borrada)

		cfg.context = nullptr;
		cfg.read = flash_read;
		cfg.prog = flash_prog;
		cfg.erase = flash_erase;
		cfg.sync = block_device_sync;
		cfg.block_size = LFS_BLOCK_SIZE;
		cfg.block_count = LFS_BLOCK_COUNT;
		cfg.lookahead_size = 8;
		cfg.block_cycles = 500;
		cfg.read_size = 2;
		cfg.prog_size = 2;
		cfg.cache_size = 8;

		int error = lfs_mount(&lfs, &cfg);
		if (error != LFS_ERR_OK)
		{
			lfs_format(&lfs, &cfg);
			LOG("FileSystem formating...\n");
			error = lfs_mount(&lfs, &cfg);
			if (error != LFS_ERR_OK) {
				LOG("[ERROR] FileSystem formating failed.\n");
			}

			// Its seems that is the first time, so the Flash must be formatted to support files.
			// Get de Autogenerated JSON data and put it in the Flash.
			for (const auto& [fileName, jsonContent] : json_data) {
				Write(fileName, jsonContent);
			}
		}
		else
		{
			LOG("FileSystem monted.\n");
		}
	}

	~FileManager() {
		lfs_unmount(&lfs);
	}

	void Write(std::string_view fileName, std::string_view jsonContent)
	{
		lfs_file_t file;
		if (lfs_file_open(&lfs, &file, fileName.data(), LFS_O_WRONLY | LFS_O_CREAT) == LFS_ERR_OK) {
			lfs_file_write(&lfs, &file, jsonContent.data(), (lfs_size_t)jsonContent.size());
			lfs_file_close(&lfs, &file);
			LOG("[INFO] File %s writed.\n", fileName.data());
		}
		else {
			LOG("[ERROR] Cannot open the file %s to write.\n", fileName.data());
		}
	}

	std::optional<std::string> Load(std::string_view filename)
	{
		return std::nullopt;
	}


	std::optional<std::string> Read(std::string_view filename) 
	{
		lfs_file_t file;
		if (lfs_file_open(&lfs, &file, filename.data(), LFS_O_RDONLY) != LFS_ERR_OK) {
			LOG("[ERROR] Cannot open the file %s to read.\n", filename.data());
			return std::nullopt;
		}

		lfs_soff_t file_size = lfs_file_size(&lfs, &file);
		if (file_size <= 0) {
			LOG("[ERROR] Invalid fileSize for %s.\n", filename.data());
			lfs_file_close(&lfs, &file);
			return std::nullopt;
		}

		std::string content(file_size, '\0');

		int read_size = lfs_file_read(&lfs, &file, &content[0], file_size);
		if (read_size < 0) {
			LOG("[ERROR] Fail to open %s.\n", filename.data());
			lfs_file_close(&lfs, &file);
			return std::nullopt;
		}

		lfs_file_close(&lfs, &file);
		LOG("[INFO] Reading %s.\n",filename.data());
		return content;
	}

	// Escribe datos en un archivo
	void SendToMicroSD(std::string_view filename, std::string_view data)
	{
		//lfs_file_t file;
		//if (lfs_file_open(&lfs, &file, filename.data(), LFS_O_WRONLY | LFS_O_CREAT) == LFS_ERR_OK) {
		//	lfs_file_write(&lfs, &file, data.data(), (lfs_size_t)data.size());
		//	lfs_file_close(&lfs, &file);
		//	std::cout << "[INFO] Archivo escrito: " << filename << "\n";
		//}
		//else {
		//	std::cerr << "[ERROR] No se pudo abrir el archivo para escribir: " << filename << "\n";
		//}
	}

private:
	static constexpr size_t FLASH_SIZE = LFS_BLOCK_SIZE * LFS_BLOCK_COUNT;
	static inline char flash_buffer[FLASH_SIZE] = {};

	lfs_t lfs;              // Estructura principal de LittleFS
	struct lfs_config cfg;  // Configuración del dispositivo para LittleFS

	// Función de sincronización (no hace nada en este caso)
	static int block_device_sync(const struct lfs_config* c) {
		return LFS_ERR_OK;
	}

	// Simula la lectura de la Flash
	static int flash_read(const struct lfs_config* context, lfs_block_t block, lfs_off_t offset, void* buffer, lfs_size_t size) {
		std::memcpy(buffer, flash_buffer + block * LFS_BLOCK_SIZE + offset, size);
		return LFS_ERR_OK;
	}

	// Simula la escritura en la Flash
	static int flash_prog(const struct lfs_config* context, lfs_block_t block, lfs_off_t offset, const void* buffer, lfs_size_t size) {
		std::memcpy(flash_buffer + block * LFS_BLOCK_SIZE + offset, buffer, size);
		return LFS_ERR_OK;
	}

	// Simula el borrado de un bloque de Flash
	static int flash_erase(const struct lfs_config* context, lfs_block_t block) {
		std::memset(flash_buffer + block * LFS_BLOCK_SIZE, 0xFF, LFS_BLOCK_SIZE);
		return LFS_ERR_OK;
	}
};

/////////////////////////////////////////////////
inline FileManager FILEMANAGER; /// OBJETO GLOBAL
/////////////////////////////////////////////////

#endif /* APPLICATION_FILEMANAGER_FILEMANAGER_HPP_ */
