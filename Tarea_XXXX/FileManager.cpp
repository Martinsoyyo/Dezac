#include "DataManager.hpp"
#include "FileManager.hpp"
#include "Autogenerated_JSONData.hpp"


void FileManager::Init(const Value& doc) 
{
	LOG("FileManager::Init(...)\n");


	std::memset(flash_buffer, 0xFF, FLASH_SIZE); // Inicializa con 0xFF (Flash borrada)

	cfg.context = nullptr;
	cfg.read = flash_read;
	cfg.prog = flash_prog;
	cfg.erase = flash_erase;
	cfg.sync = block_device_sync;
	cfg.block_size = LFS_BLOCK_SIZE;
	cfg.block_count = LFS_BLOCK_COUNT;
	cfg.lookahead_size = 8;
	cfg.block_cycles = 500;
	cfg.read_size = 2;
	cfg.prog_size = 2;
	cfg.cache_size = 8;

	int error = lfs_mount(&lfs, &cfg);
	if (error != LFS_ERR_OK)
	{
		lfs_format(&lfs, &cfg);
		LOG("FileSystem formating...\n");
		error = lfs_mount(&lfs, &cfg);
		if (error != LFS_ERR_OK) {
			LOG("[ERROR] FileSystem formating failed.\n");
		}

		// Its seems that is the first time, so the Flash must be formatted to support files.
		// Get de Autogenerated JSON data and put it in the Flash.
		for (const auto& [fileName, jsonContent] : json_data) {
			Write(fileName, jsonContent);
		}
	}
	else
	{
		LOG("FileSystem monted.\n");
	}
}

void FileManager::Write(std::string_view fileName, std::string_view jsonContent)
{
	lfs_file_t file;
	if (lfs_file_open(&lfs, &file, fileName.data(), LFS_O_WRONLY | LFS_O_CREAT) == LFS_ERR_OK) {
		lfs_file_write(&lfs, &file, jsonContent.data(), (lfs_size_t)jsonContent.size());
		lfs_file_close(&lfs, &file);
		LOG("[INFO] File %s writed.\n", fileName.data());
	}
	else {
		LOG("[ERROR] Cannot open the file %s to write.\n", fileName.data());
	}
}

std::optional<std::string> FileManager::Read(std::string_view filename)
{
	lfs_file_t file;
	if (lfs_file_open(&lfs, &file, filename.data(), LFS_O_RDONLY) != LFS_ERR_OK) {
		LOG("[ERROR] Cannot open the file %s to read.\n", filename.data());
		return std::nullopt;
	}

	lfs_soff_t file_size = lfs_file_size(&lfs, &file);
	if (file_size <= 0) {
		lfs_file_close(&lfs, &file);
		LOG("[ERROR] Invalid fileSize for %s.\n", filename.data());
		return std::nullopt;
	}

	std::string content(file_size + 1, '\0');
	content[file_size] = '\n';

	int read_size = lfs_file_read(&lfs, &file, &content[0], file_size);
	if (read_size < 0) {
		lfs_file_close(&lfs, &file);
		LOG("[ERROR] Fail to open %s.\n", filename.data());
		return std::nullopt;
	}

	lfs_file_close(&lfs, &file);
	LOG("[INFO] Reading %s.\n", filename.data());
	return content;
}

std::optional<std::string> FileManager::Load(std::string_view filename)
{
	// Loading from uSD, we need to implement that in stm32.
	return std::nullopt;
}

void FileManager::SendToMicroSD(std::string_view filename, std::string_view data)
{
	// Store to uSD, we need to implement that in stm32.
}